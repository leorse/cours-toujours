{% extends "base.html" %}

{% block title %}Entraînement: {{ step.title }} - Cours Toujours!{% endblock %}

{% block content %}
<div class="test-container" style="max-width: 900px; margin: 2rem auto; padding: 0 1rem;">
    <header style="margin-bottom: 3rem; text-align: center;">
        <h1 style="font-size: 2.5rem; margin-bottom: 1rem;">{{ step.title }}</h1>
        <p style="color: var(--text-muted);">Cours : {{ course.title }}</p>
        <a href="/subjects/{{ course.subject_id }}" style="color: var(--secondary); text-decoration: none;">&larr;
            Revenir à la route</a>
    </header>

    <div class="glass glass-panel animate-fade-in">
        <div id="exercises-list">
            <!-- Exercises will be rendered here by JS -->
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/fraction_renderer.js"></script>
<script>
    // Pass the GENERATED exercises here, not the course.exercises directly
    const stepData = {
        id: "{{ step.id }}",
        exercises: {{ exercises | tojson }}
    };
    const userId = {{ user.id }};
    // In test mode, we might not show previous progress immediately, or maybe we do?
    // Let's assume a fresh test attempt or just standard submission.
    // If we want to allow retries, we might not pre-fill progress unless it's a "saved state".
    // For simplicity: New attempt every time or handled by backend submission logic.
    const userProgress = null;
    const isCompleted = false; // Always allow interaction in test mode until submitted

    document.addEventListener('DOMContentLoaded', () => {
        renderExercises();

        // Render Math with KaTeX
        renderMathInElement(document.getElementById('exercises-list'), {
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false }
            ],
            throwOnError: false
        });
    });

    function renderExercises() {
        const container = document.getElementById('exercises-list');
        container.innerHTML = '';

        if (!stepData.exercises || stepData.exercises.length === 0) {
            container.innerHTML = '<p class="text-muted">Aucune question générée.</p>';
            return;
        }

        stepData.exercises.forEach((ex, index) => {
            const card = document.createElement('div');
            card.className = 'exercise-card';
            card.style.marginBottom = '3rem';
            card.style.paddingBottom = '2rem';
            card.style.borderBottom = '1px solid var(--glass-border)';

            // Render specific exercise types
            let contentHtml = '';

            if (ex.type === 'drag_drop') {
                let templateText = ex.template || '';
                let parts = templateText.split('???');
                let newHtml = '';

                parts.forEach((part, i) => {
                    newHtml += part;
                    if (i < parts.length - 1) {
                        const zoneId = `zone-${ex.id}-${i}`;
                        newHtml += `<span class="drop-zone" id="${zoneId}" ondrop="drop(event, '${ex.id}', ${i})" ondragover="allowDrop(event)"></span>`;
                    }
                });

                contentHtml = `
                    <div style="margin-bottom: 1.5rem; font-size: 1.1rem; line-height: 2;">${newHtml}</div>
                    <div class="options-container" style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">
                        ${ex.options.map(opt => {
                    return `<div class="draggable-item" draggable="true" ondragstart="drag(event, '${opt.replace(/'/g, "\\'")}')">${opt}</div>`;
                }).join('')}
                    </div>
                `;
            } else if (ex.type === 'fraction_scenario') {
                const cId = `visual-${ex.id}`;
                contentHtml = `
                    <div id="${cId}" style="margin: 0 auto 1.5rem auto; width: 100%; max-width: 300px; height: 300px;"></div>
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question}</p>
                    <input type="text" placeholder="Votre réponse" 
                        onchange="saveInput(this, '${ex.id}')" 
                        style="width: 100%; padding: 1rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary); margin-bottom: 1rem;">
                `;
                setTimeout(() => {
                    if (window.FractionRenderer) {
                        FractionRenderer.render(cId, ex);
                    }
                }, 100);
            } else if (ex.type === 'input') {
                contentHtml = `
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question || ex.template || ''}</p>
                    <input type="text" placeholder="Votre réponse" 
                        onchange="saveInput(this, '${ex.id}')" 
                        style="width: 100%; padding: 1rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary);">
                `;
            } else {
                // MCQ / QCM
                const options = ex.options || [];
                contentHtml = `
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question || ex.template || ''}</p>
                    <div class="options-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        ${options.map((opt, optIndex) => {
                    return `
                                <button class="option-btn" onclick="selectOption(this, '${ex.id}', ${optIndex})">
                                    ${opt}
                                </button>
                            `;
                }).join('')}
                    </div>
                `;
            }

            card.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 1rem; color: var(--secondary); font-size: 1.1em;">
                    Question ${index + 1}
                </div>
                ${contentHtml}
                <div id="feedback-${ex.id}" style="margin-top: 1rem; font-weight: bold;"></div>
            `;
            container.appendChild(card);
        });

        const submitBtn = document.createElement('button');
        submitBtn.className = 'btn-primary';
        submitBtn.style.width = '100%';
        submitBtn.style.marginTop = '2rem';
        submitBtn.style.fontSize = '1.2rem';
        submitBtn.style.padding = '1rem';
        submitBtn.textContent = 'Valider le Test';
        submitBtn.onclick = submitTest;
        container.appendChild(submitBtn);
    }

    const userAnswers = {};

    function saveInput(input, exId) {
        userAnswers[exId] = input.value;
    }

    function selectOption(btn, exId, optIndex) {
        // Find the exercise object
        const ex = stepData.exercises.find(e => e.id === exId);
        if (!ex) return;

        const value = ex.options[optIndex];

        const parent = btn.parentElement;
        parent.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        userAnswers[exId] = value;
    }

    function allowDrop(ev) {
        ev.preventDefault();
        ev.target.classList.add('drag-over');
    }

    function drag(ev, value) {
        ev.dataTransfer.setData("text", value);
    }

    function drop(ev, exId, zoneIndex = 0) {
        ev.preventDefault();
        ev.target.classList.remove('drag-over');
        var data = ev.dataTransfer.getData("text");
        ev.target.textContent = data;
        ev.target.classList.add('filled');
        if (!userAnswers[exId]) userAnswers[exId] = [];
        if (typeof userAnswers[exId] === 'string') userAnswers[exId] = [userAnswers[exId]];
        userAnswers[exId][zoneIndex] = data;
    }

    async function submitTest() {
        if (Object.keys(userAnswers).length < stepData.exercises.length) {
            if (!confirm("Vous n'avez pas répondu à toutes les questions. Voulez-vous vraiment valider ?")) {
                return;
            }
        }

        try {
            // Need a specific endpoint for test submission if logic differs, 
            // but we can reuse /submit if we pass a special flag or just handle it as normal.
            // However, the generated exercises (IDs) must be recognized by the backend verification.
            // Problem: The backend 'submit' function fetches the course from DB and compares answers against 'course.exercises'.
            // BUT, our generated exercises are NOT in the DB 'course.exercises'.
            // WE NEED TO SEND THE QUESTIONS/ANSWERS TO THE BACKEND OR (BETTER) STORE THE GENERATED TEST TEMPORARILY.
            // OR: We include the Expected Answer in the submission token? No, insecure.
            // OR: We just handle "Standard" exercises validation via DB, and "Generated" via helper?
            // Actually, the simplest for this prototype is to send the expected answers encoded or simplified, OR
            // Make the 'submit' endpoint capable of verifying generated questions based on ID signature?
            // 'gen_simp_...' -> ID implies we can re-verify? No, we need the specific numbers.

            // SOLUTION: Pass the full exercise set (with answers!) to the client? - Insecure.
            // Better: Store the generated test in a Server-Side Session?
            // Since we don't have Redis/sessions easily set up beyond cookies...
            // Let's use a signed token or just trust the client for this specific "local" app context? 
            // The User is the student.

            // To be robust:
            // The /submit endpoint needs to know what the correct answers were.
            // We can send the "generated_exercises" back to the server in the submit body?
            // Yes, user could cheat by inspecting payload, but for this app level it's fine.

            const response = await fetch('/submit_test_step', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_id: userId,
                    step_id: stepData.id,
                    answers: userAnswers,
                    // Sending back the exercises so server knows what the questions were
                    generated_exercises: stepData.exercises
                })
            });

            const result = await response.json();

            // Show Feedback
            let correctCount = 0;
            for (const [exId, res] of Object.entries(result.results)) {
                const isCorrect = res.correct;
                if (isCorrect) correctCount++;

                const fbDiv = document.getElementById(`feedback-${exId}`);
                if (fbDiv) {
                    fbDiv.innerHTML = isCorrect ? "✅ Correct" : `❌ Incorrect (Réponse: ${res.correct_answer})`;
                    fbDiv.style.color = isCorrect ? "var(--success)" : "var(--error)";

                    // Render Math in feedback
                    renderMathInElement(fbDiv, {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false }
                        ],
                        throwOnError: false
                    });
                }
            }

            alert(`Étape terminée ! Score: ${correctCount} / ${stepData.exercises.length}`);

            if (result.xp_gained > 0) {
                if (result.xp_gained > 0) {
                    confetti({
                        particleCount: 150,
                        spread: 80,
                        origin: { y: 0.6 }
                    });
                }
            }

            // Disable inputs?
            document.querySelectorAll('button').forEach(b => b.disabled = true);

        } catch (error) {
            console.error('Error submitting:', error);
            alert('Erreur lors de la soumission');
        }
    }
</script>
{% endblock %}