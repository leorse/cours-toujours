{% extends "base.html" %}

{% block title %}Entra√Ænement: {{ step.title }} - Cours Toujours!{% endblock %}

{% block content %}
<div class="test-container" style="max-width: 900px; margin: 2rem auto; padding: 0 1rem;">
    <header style="margin-bottom: 3rem; text-align: center;">
        <h1 style="font-size: 2.5rem; margin-bottom: 1rem;">{{ step.title }}</h1>
        <p style="color: var(--text-muted);">Cours : {{ course.title }}</p>
        <a href="/subjects/{{ course.subject_id }}" style="color: var(--secondary); text-decoration: none;">&larr;
            Revenir √† la route</a>
    </header>

    <div class="glass glass-panel animate-fade-in">
        <div id="exercises-list">
            <!-- Exercises will be rendered here by JS -->
        </div>
    </div>
    {% if user.is_admin %}
    <div class="admin-toolbar glass"
        style="position: fixed; bottom: 20px; right: 20px; padding: 1rem; z-index: 1000; border: 1px solid var(--secondary);">
        <h4 style="margin: 0 0 0.5rem 0; color: var(--secondary);">Admin Mode</h4>
        <button onclick="simulatePerfectScore()"
            style="display: block; width: 100%; margin-bottom: 0.5rem; font-size: 0.8rem;">Simuler Score
            Parfait</button>
        <button onclick="submitTest()" style="display: block; width: 100%; font-size: 0.8rem;">Valider le Test</button>
    </div>
    <script>
        function simulatePerfectScore() {
            // Fill all answers with correct ones
            if (!stepData || !stepData.exercises) return;

            stepData.exercises.forEach(ex => {
                // Update logic state
                userAnswers[ex.id] = ex.answer;

                // Update UI
                if (ex.type === 'input') {
                    const input = document.querySelector(`input[onchange*="${ex.id}"]`);
                    if (input) input.value = ex.answer;
                } else if (ex.type === 'fraction_scenario') {
                    const input = document.querySelector(`input[onchange*="${ex.id}"]`);
                    if (input) input.value = ex.answer;
                } else if (ex.type === 'qcm' || ex.type === 'multiselect') {
                    // Find option matching answer
                    // Note: ex.answer is string, options are list of strings
                    // We need to click the button
                    // This is a bit tricky if we don't have direct ref, but we can search text
                    const buttons = document.querySelectorAll(`button[onclick*="${ex.id}"]`);
                    buttons.forEach(btn => {
                        if (btn.innerText.trim() === ex.answer) {
                            btn.click(); // Trigger selection logic
                        }
                    });
                } else if (ex.type === 'drag_drop') {
                    // Drag drop is complex to simulate visually without recreating DOM
                    // But we can just set the state and maybe fill the text?
                    const parts = document.querySelectorAll(`span[id^="zone-${ex.id}"]`);
                    parts.forEach((part, i) => {
                        // We need to parse answer if it's array? 
                        // ex.answer might be "A, B" or ["A", "B"]? 
                        // Check models or generator
                        // MathGenerator returns string. 
                        // But DragDrop is likely custom. 
                        // Assuming simple string for now or list handling elsewhere.
                        // The submit logic sends userAnswers[ex.id].
                        // Let's just set the text content to debug
                        part.innerHTML = "DONE";
                        part.classList.add('filled');
                    });
                }
            });
            alert("Score parfait simul√© (Donn√©es remplies). Vous pouvez valider.");
        }
    </script>
    {% endif %}

</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/fraction_renderer.js"></script>
<script src="/static/js/blueprint_renderer.js"></script>
<script>
    // Pass the GENERATED exercises here, not the course.exercises directly
    const stepData = {
        id: "{{ step.id }}",
        exercises: {{ exercises | tojson }}
    };
    const userId = {{ user.id }};
    // In test mode, we might not show previous progress immediately, or maybe we do?
    // Let's assume a fresh test attempt or just standard submission.
    // If we want to allow retries, we might not pre-fill progress unless it's a "saved state".
    // For simplicity: New attempt every time or handled by backend submission logic.
    const userProgress = null;
    const isCompleted = false; // Always allow interaction in test mode until submitted

    document.addEventListener('DOMContentLoaded', () => {
        renderExercises();

        // Render Math with KaTeX
        renderMathInElement(document.getElementById('exercises-list'), {
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false }
            ],
            throwOnError: false
        });
    });

    function renderExercises() {
        const container = document.getElementById('exercises-list');
        container.innerHTML = '';

        if (!stepData.exercises || stepData.exercises.length === 0) {
            container.innerHTML = '<p class="text-muted">Aucune question g√©n√©r√©e.</p>';
            return;
        }

        stepData.exercises.forEach((ex, index) => {
            const card = document.createElement('div');
            card.className = 'exercise-card';
            card.style.marginBottom = '3rem';
            card.style.paddingBottom = '2rem';
            card.style.borderBottom = '1px solid var(--glass-border)';

            // Render specific exercise types
            let contentHtml = '';

            if (ex.type === 'drag_drop') {
                let templateText = ex.template || '';
                let parts = templateText.split('???');
                let newHtml = '';

                parts.forEach((part, i) => {
                    newHtml += part;
                    if (i < parts.length - 1) {
                        const zoneId = `zone-${ex.id}-${i}`;
                        newHtml += `<span class="drop-zone" id="${zoneId}" ondrop="drop(event, '${ex.id}', ${i})" ondragover="allowDrop(event)"></span>`;
                    }
                });

                contentHtml = `
                    <div style="margin-bottom: 1.5rem; font-size: 1.1rem; line-height: 2;">${newHtml}</div>
                    <div class="options-container" style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">
                        ${ex.options.map(opt => {
                    return `<div class="draggable-item" draggable="true" ondragstart="drag(event, '${opt.replace(/'/g, "\\'")}')">${opt}</div>`;
                }).join('')}
                    </div>
                `;
            } else if (ex.type === 'fraction_scenario') {
                const cId = `visual-${ex.id}`;
                contentHtml = `
                    <div id="${cId}" style="margin: 0 auto 1.5rem auto; width: 100%; max-width: 300px; height: 300px;"></div>
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question}</p>
                    <input type="text" placeholder="Votre r√©ponse" 
                        onchange="saveInput(this, '${ex.id}')" 
                        style="width: 100%; padding: 1rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary); margin-bottom: 1rem;">
                `;
                setTimeout(() => {
                    if (window.FractionRenderer) {
                        FractionRenderer.render(cId, ex);
                    }
                }, 100);
            } else if (ex.type === 'input') {
                // Check if we have a blueprint in metadata
                let blueprintHtml = '';
                if (ex.meta && ex.meta.visual_blueprint) {
                    const vid = `blueprint-${ex.id}`;
                    blueprintHtml = `<div id="${vid}" style="margin: 0 auto 1.5rem auto; width: 100%; max-width: 400px; text-align:center;"></div>`;
                    setTimeout(() => {
                        if (window.BlueprintRenderer) {
                            BlueprintRenderer.render(vid, ex.meta.visual_blueprint);
                        }
                    }, 100);
                }

                contentHtml = `
                    ${blueprintHtml}
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question || ex.template || ''}</p>
                    <input type="text" placeholder="Votre r√©ponse" 
                        onchange="saveInput(this, '${ex.id}')" 
                        style="width: 100%; padding: 1rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary);">
                `;
            } else {
                // MCQ / QCM
                const options = ex.options || [];
                contentHtml = `
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question || ex.template || ''}</p>
                    <div class="options-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        ${options.map((opt, optIndex) => {
                    return `
                                <button class="option-btn" onclick="selectOption(this, '${ex.id}', ${optIndex})">
                                    ${opt}
                                </button>
                            `;
                }).join('')}
                    </div>
                `;
            }

            card.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 1rem; color: var(--secondary); font-size: 1.1em;">
                    Question ${index + 1}
                </div>
                ${contentHtml}
                <div id="feedback-${ex.id}" style="margin-top: 1rem; font-weight: bold;"></div>
            `;
            container.appendChild(card);
        });

        const submitBtn = document.createElement('button');
        submitBtn.className = 'btn-primary';
        submitBtn.style.width = '100%';
        submitBtn.style.marginTop = '2rem';
        submitBtn.style.fontSize = '1.2rem';
        submitBtn.style.padding = '1rem';
        submitBtn.textContent = 'Valider le Test';
        submitBtn.onclick = submitTest;
        container.appendChild(submitBtn);
    }

    const userAnswers = {};

    function saveInput(input, exId) {
        userAnswers[exId] = input.value;
    }

    function selectOption(btn, exId, optIndex) {
        // Find the exercise object
        const ex = stepData.exercises.find(e => e.id === exId);
        if (!ex) return;

        const value = ex.options[optIndex];

        const parent = btn.parentElement;
        parent.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        userAnswers[exId] = value;
    }

    function allowDrop(ev) {
        ev.preventDefault();
        ev.target.classList.add('drag-over');
    }

    function drag(ev, value) {
        ev.dataTransfer.setData("text", value);
    }

    function drop(ev, exId, zoneIndex = 0) {
        ev.preventDefault();
        ev.target.classList.remove('drag-over');
        var data = ev.dataTransfer.getData("text");
        ev.target.textContent = data;
        ev.target.classList.add('filled');
        if (!userAnswers[exId]) userAnswers[exId] = [];
        if (typeof userAnswers[exId] === 'string') userAnswers[exId] = [userAnswers[exId]];
        userAnswers[exId][zoneIndex] = data;
    }

    async function submitTest() {
        if (Object.keys(userAnswers).length < stepData.exercises.length) {
            if (!confirm("Vous n'avez pas r√©pondu √† toutes les questions. Voulez-vous vraiment valider ?")) {
                return;
            }
        }

        try {
            // Need a specific endpoint for test submission if logic differs, 
            // but we can reuse /submit if we pass a special flag or just handle it as normal.
            // However, the generated exercises (IDs) must be recognized by the backend verification.
            // Problem: The backend 'submit' function fetches the course from DB and compares answers against 'course.exercises'.
            // BUT, our generated exercises are NOT in the DB 'course.exercises'.
            // WE NEED TO SEND THE QUESTIONS/ANSWERS TO THE BACKEND OR (BETTER) STORE THE GENERATED TEST TEMPORARILY.
            // OR: We include the Expected Answer in the submission token? No, insecure.
            // OR: We just handle "Standard" exercises validation via DB, and "Generated" via helper?
            // Actually, the simplest for this prototype is to send the expected answers encoded or simplified, OR
            // Make the 'submit' endpoint capable of verifying generated questions based on ID signature?
            // 'gen_simp_...' -> ID implies we can re-verify? No, we need the specific numbers.

            // SOLUTION: Pass the full exercise set (with answers!) to the client? - Insecure.
            // Better: Store the generated test in a Server-Side Session?
            // Since we don't have Redis/sessions easily set up beyond cookies...
            // Let's use a signed token or just trust the client for this specific "local" app context? 
            // The User is the student.

            // To be robust:
            // The /submit endpoint needs to know what the correct answers were.
            // We can send the "generated_exercises" back to the server in the submit body?
            // Yes, user could cheat by inspecting payload, but for this app level it's fine.

            const response = await fetch('/submit_test_step', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_id: userId,
                    step_id: stepData.id,
                    answers: userAnswers,
                    // Sending back the exercises so server knows what the questions were
                    generated_exercises: stepData.exercises
                })
            });

            const result = await response.json();

            // Show Feedback
            let correctCount = 0;
            for (const [exId, res] of Object.entries(result.results)) {
                const isCorrect = res.correct;
                if (isCorrect) correctCount++;

                const fbDiv = document.getElementById(`feedback-${exId}`);
                if (fbDiv) {
                    fbDiv.innerHTML = isCorrect ? "‚úÖ Correct" : `‚ùå Incorrect (R√©ponse: ${res.correct_answer})`;
                    fbDiv.style.color = isCorrect ? "var(--success)" : "var(--error)";

                    // Render Math in feedback
                    renderMathInElement(fbDiv, {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false }
                        ],
                        throwOnError: false
                    });
                }
            }

            // Mastery Feedback
            let masteryMsg = "";
            let mastery = result.mastery;
            if (mastery === 3) masteryMsg = "üèÜ MA√éTRISE OR ! (3/3)";
            else if (mastery === 2) masteryMsg = "ü•à Ma√Ætrise Argent (2/3)";
            else if (mastery === 1) masteryMsg = "ü•â Ma√Ætrise Bronze (1/3)";

            let msg = `√âtape termin√©e ! Score: ${correctCount} / ${stepData.exercises.length}`;
            if (masteryMsg) msg += `\n\n${masteryMsg}`;

            alert(msg);

            if (result.xp_gained > 0) {
                confetti({
                    particleCount: 150,
                    spread: 80,
                    origin: { y: 0.6 }
                });
            }

            // Disable inputs?
            document.querySelectorAll('button').forEach(b => b.disabled = true);

        } catch (error) {
            console.error('Error submitting:', error);
            alert('Erreur lors de la soumission');
        }
    }
</script>
{% endblock %}