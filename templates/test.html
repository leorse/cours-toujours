{% extends "base.html" %}

{% block title %}{{ step.title }} - Parcours{% endblock %}

{% block content %}
<div class="test-container" style="max-width: 900px; margin: 2rem auto; padding: 0 1rem;">
    <header style="margin-bottom: 3rem; text-align: center;">
        <h1 style="font-size: 2.5rem; margin-bottom: 1rem;">{{ step.title }}</h1>
        <p style="color: var(--text-muted);">Cours : {{ course.title }}</p>
        <a href="/subjects/{{ course.subject_id }}#{{ step.id }}"
            style="color: var(--secondary); text-decoration: none;">&larr;
            Revenir √† la route</a>
    </header>

    <div class="glass glass-panel animate-fade-in">
        <div id="exercises-list">
            <!-- Exercises will be rendered here by JS -->
        </div>
    </div>
    {% if user.is_admin %}
    <div class="admin-toolbar glass"
        style="position: fixed; bottom: 20px; right: 20px; padding: 1rem; z-index: 1000; border: 1px solid var(--secondary);">
        <h4 style="margin: 0 0 0.5rem 0; color: var(--secondary);">Admin Mode</h4>
        <button onclick="simulatePerfectScore()"
            style="display: block; width: 100%; margin-bottom: 0.5rem; font-size: 0.8rem;">Simuler Score
            Parfait</button>
        <button onclick="submitTest()"
            style="display: block; width: 100%; font-size: 0.8rem; margin-bottom: 0.5rem;">Valider le Test
            (Submit)</button>
        <a href="/admin/validate_step/{{ step.id }}"
            style="display: block; width: 100%; font-size: 0.8rem; margin-bottom: 0.5rem; text-align: center; background: #eee; color: #333; text-decoration: none; padding: 2px;">Force
            Valider</a>
        <a href="/admin/invalidate_step/{{ step.id }}"
            style="display: block; width: 100%; font-size: 0.8rem; text-align: center; background: #fee; color: red; text-decoration: none; padding: 2px;">Invalider</a>
    </div>
    <script>
        function simulatePerfectScore() {
            if (!stepData || !stepData.exercises) return;
            stepData.exercises.forEach(ex => solveExercise(ex));
            alert("Score parfait simul√© (Donn√©es remplies). Vous pouvez valider.");
        }

        function solveExercise(ex) {
            if (ex.type === 'input' || ex.type === 'fraction_scenario') {
                const input = document.querySelector(`input[onchange*="${ex.id}"]`);
                if (input) {
                    input.value = ex.answer;
                    userAnswers[ex.id] = ex.answer;
                }
            } else if (ex.type === 'drag_drop') {
                const zones = document.querySelectorAll(`[id^="zone-${ex.id}"]`);
                zones.forEach((zone, i) => {
                    zone.textContent = ex.answer[i];
                    zone.classList.add('filled');
                });
                userAnswers[ex.id] = [...ex.answer];
            } else if (ex.type === 'cloze') {
                const selects = document.querySelectorAll(`select[onchange*="${ex.id}"]`);
                selects.forEach((sel, i) => {
                    sel.value = ex.answer[i];
                    saveCloze(sel, ex.id, i);
                });
            } else if (ex.type === 'qcm' || ex.type === 'multiselect') {
                const buttons = document.querySelectorAll(`button[onclick*="${ex.id}"]`);
                if (ex.type === 'qcm') {
                    userAnswers[ex.id] = null;
                    buttons.forEach(b => b.classList.remove('selected'));
                } else {
                    userAnswers[ex.id] = [];
                    buttons.forEach(b => b.classList.remove('selected'));
                }
                buttons.forEach(btn => {
                    const btnVal = btn.innerText.trim();
                    const isShouldBeSelected = Array.isArray(ex.answer) ? ex.answer.includes(btnVal) : btnVal === String(ex.answer).trim();
                    if (isShouldBeSelected) btn.click();
                });
            }
        }
    </script>
    {% endif %}

</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/fraction_renderer.js"></script>
<script src="/static/js/blueprint_renderer.js"></script>
<script>
    // Pass the GENERATED exercises here, not the course.exercises directly
    const stepData = {
        id: "{{ step.id }}",
        exercises: {{ exercises | tojson }}
    };
    const userId = {{ user.id }};
    const isAdmin = {{ 'true' if user.is_admin else 'false' }};
    const userAnswers = {};

    // In test mode, we might not show previous progress immediately, or maybe we do?
    // Let's assume a fresh test attempt or just standard submission.
    // If we want to allow retries, we might not pre-fill progress unless it's a "saved state".
    // For simplicity: New attempt every time or handled by backend submission logic.
    const userProgress = null;
    const isCompleted = false; // Always allow interaction in test mode until submitted

    document.addEventListener('DOMContentLoaded', () => {
        renderExercises();

        // Render Math with KaTeX
        renderMathInElement(document.getElementById('exercises-list'), {
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false }
            ],
            throwOnError: false
        });
    });

    function renderExercises() {
        const container = document.getElementById('exercises-list');
        container.innerHTML = '';

        if (!stepData.exercises || stepData.exercises.length === 0) {
            container.innerHTML = '<p class="text-muted">Aucune question g√©n√©r√©e.</p>';
            return;
        }

        stepData.exercises.forEach((ex, index) => {
            const card = document.createElement('div');
            card.className = 'exercise-card';
            card.style.marginBottom = '3rem';
            card.style.paddingBottom = '2rem';
            card.style.borderBottom = '1px solid var(--glass-border)';
            card.style.position = 'relative';

            // Render specific exercise types
            let contentHtml = '';

            if (ex.type === 'drag_drop') {
                let templateText = ex.template || '';
                // Support both ... and ???
                let parts = templateText.split(/\.\.\.|\?\?\?/);
                let newHtml = '';

                parts.forEach((part, i) => {
                    newHtml += part;
                    if (i < parts.length - 1) {
                        const zoneId = `zone-${ex.id}-${i}`;
                        newHtml += `<span class="drop-zone" id="${zoneId}" ondrop="drop(event, '${ex.id}', ${i})" ondragover="allowDrop(event)"></span>`;
                    }
                });

                contentHtml = `
                    <div style="margin-bottom: 1.5rem; font-size: 1.2rem; line-height: 2.2;">${newHtml}</div>
                    <div class="options-container" style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">
                        ${ex.options.map(opt => {
                    return `<div class="draggable-item" draggable="true" ondragstart="drag(event, '${opt.replace(/'/g, "\\'")}')">${opt}</div>`;
                }).join('')}
                    </div>
                `;
            } else if (ex.type === 'fraction_scenario') {
                const cId = `visual-${ex.id}`;
                contentHtml = `
                    <div id="${cId}" style="margin: 0 auto 1.5rem auto; width: 100%; max-width: 300px; height: 300px;"></div>
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question}</p>
                    <input type="text" placeholder="Votre r√©ponse" 
                        onchange="saveInput(this, '${ex.id}')" 
                        style="width: 100%; padding: 1rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary); margin-bottom: 1rem;">
                `;
                setTimeout(() => {
                    if (window.FractionRenderer) {
                        FractionRenderer.render(cId, ex);
                    }
                }, 100);
            } else if (ex.type === 'cloze') {
                let templateText = ex.template || ex.question || '';
                // Support both ... and ??? as markers
                let parts = templateText.split(/\.\.\.|\?\?\?/);
                let newHtml = '';
                const options = ex.options || [];

                parts.forEach((part, i) => {
                    newHtml += part;
                    if (i < parts.length - 1) {
                        newHtml += `
                            <select onchange="saveCloze(this, '${ex.id}', ${i})" 
                                    style="padding: 0.2rem; border-radius: 4px; background: rgba(255,255,255,0.1); color: var(--text-primary); border: 1px solid var(--glass-border);">
                                <option value="">...</option>
                                ${options.map(opt => `<option value="${opt}">${opt}</option>`).join('')}
                            </select>
                        `;
                    }
                });
                contentHtml = `
                    <div style="margin-bottom: 1.5rem; line-height: 2.2; font-size: 1.2rem;">${newHtml}</div>
                `;
            } else if (ex.type === 'input') {
                // Check if we have a blueprint in metadata
                let blueprintHtml = '';
                if (ex.meta && ex.meta.visual_blueprint) {
                    const vid = `blueprint-${ex.id}`;
                    blueprintHtml = `<div id="${vid}" style="margin: 0 auto 1.5rem auto; width: 100%; max-width: 400px; text-align:center;"></div>`;
                    setTimeout(() => {
                        if (window.BlueprintRenderer) {
                            BlueprintRenderer.render(vid, ex.meta.visual_blueprint);
                        }
                    }, 100);
                }

                contentHtml = `
                    ${blueprintHtml}
                    <p style="margin-bottom: 1.5rem; font-size: 1.2rem;">${ex.question || ex.template || ''}</p>
                    <input type="text" placeholder="Votre r√©ponse" 
                        onchange="saveInput(this, '${ex.id}')" 
                        style="width: 100%; padding: 1rem; border-radius: 8px; border: 1px solid var(--glass-border); background: rgba(255,255,255,0.1); color: var(--text-primary);">
                `;
            } else {
                // MCQ / QCM / Multiselect
                const options = ex.options || [];
                const isMulti = ex.type === 'multiselect';
                contentHtml = `
                    <p style="margin-bottom: 0.5rem; font-size: 1.2rem;">${ex.question || ex.template || ''}</p>
                    ${isMulti ? '<p style="font-size: 0.8rem; color: var(--secondary); margin-bottom: 1.5rem;">(Plusieurs r√©ponses possibles)</p>' : ''}
                    <div class="options-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                        ${options.map((opt, optIndex) => {
                    return `
                                <button class="option-btn" onclick="selectOption(this, '${ex.id}', ${optIndex})">
                                    ${opt}
                                </button>
                            `;
                }).join('')}
                    </div>
                `;
            }

            let adminBtnHtml = '';
            if (isAdmin) {
                adminBtnHtml = `
                    <button onclick='solveExercise(stepData.exercises[${index}])' 
                            style="position: absolute; top: 0; right: 0; background: var(--secondary); color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; cursor: pointer;">
                        Auto-Valid (Admin)
                    </button>
                    `;
            }

            card.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 1rem; color: var(--secondary); font-size: 1.1em;">
                    Question ${index + 1}
                </div>
                ${adminBtnHtml}
                ${contentHtml}
                <div id="feedback-${ex.id}" style="margin-top: 1rem; font-weight: bold;"></div>
            `;
            container.appendChild(card);
        });

        const submitBtn = document.createElement('button');
        submitBtn.className = 'btn-primary';
        submitBtn.style.width = '100%';
        submitBtn.style.marginTop = '2rem';
        submitBtn.style.fontSize = '1.2rem';
        submitBtn.style.padding = '1rem';
        submitBtn.textContent = 'Valider le Test';
        submitBtn.onclick = submitTest;
        container.appendChild(submitBtn);
    }

    function saveInput(input, exId) {
        userAnswers[exId] = input.value;
    }

    function saveCloze(select, exId, index) {
        if (!userAnswers[exId]) userAnswers[exId] = [];
        if (!Array.isArray(userAnswers[exId])) userAnswers[exId] = [];
        userAnswers[exId][index] = select.value;
    }

    function selectOption(btn, exId, optIndex) {
        // Find the exercise object
        const ex = stepData.exercises.find(e => e.id === exId);
        if (!ex) return;

        const value = ex.options[optIndex];

        if (ex.type === 'multiselect') {
            if (!userAnswers[exId]) userAnswers[exId] = [];
            if (!Array.isArray(userAnswers[exId])) userAnswers[exId] = []; // Reset if it was a string by accident

            if (userAnswers[exId].includes(value)) {
                userAnswers[exId] = userAnswers[exId].filter(v => v !== value);
                btn.classList.remove('selected');
            } else {
                userAnswers[exId].push(value);
                btn.classList.add('selected');
            }
        } else {
            const parent = btn.parentElement;
            parent.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            userAnswers[exId] = value;
        }
    }

    function allowDrop(ev) {
        ev.preventDefault();
        ev.target.classList.add('drag-over');
    }

    function drag(ev, value) {
        ev.dataTransfer.setData("text", value);
    }

    function drop(ev, exId, zoneIndex = 0) {
        ev.preventDefault();
        ev.target.classList.remove('drag-over');
        var data = ev.dataTransfer.getData("text");
        ev.target.textContent = data;
        ev.target.classList.add('filled');
        if (!userAnswers[exId]) userAnswers[exId] = [];
        if (typeof userAnswers[exId] === 'string') userAnswers[exId] = [userAnswers[exId]];
        userAnswers[exId][zoneIndex] = data;
    }

    async function submitTest() {
        if (Object.keys(userAnswers).length < stepData.exercises.length) {
            if (!confirm("Vous n'avez pas r√©pondu √† toutes les questions. Voulez-vous vraiment valider ?")) {
                return;
            }
        }

        try {
            // Need a specific endpoint for test submission if logic differs, 
            // but we can reuse /submit if we pass a special flag or just handle it as normal.
            // However, the generated exercises (IDs) must be recognized by the backend verification.
            // Problem: The backend 'submit' function fetches the course from DB and compares answers against 'course.exercises'.
            // BUT, our generated exercises are NOT in the DB 'course.exercises'.
            // WE NEED TO SEND THE QUESTIONS/ANSWERS TO THE BACKEND OR (BETTER) STORE THE GENERATED TEST TEMPORARILY.
            // OR: We include the Expected Answer in the submission token? No, insecure.
            // OR: We just handle "Standard" exercises validation via DB, and "Generated" via helper?
            // Actually, the simplest for this prototype is to send the expected answers encoded or simplified, OR
            // Make the 'submit' endpoint capable of verifying generated questions based on ID signature?
            // 'gen_simp_...' -> ID implies we can re-verify? No, we need the specific numbers.

            // SOLUTION: Pass the full exercise set (with answers!) to the client? - Insecure.
            // Better: Store the generated test in a Server-Side Session?
            // Since we don't have Redis/sessions easily set up beyond cookies...
            // Let's use a signed token or just trust the client for this specific "local" app context? 
            // The User is the student.

            // To be robust:
            // The /submit endpoint needs to know what the correct answers were.
            // We can send the "generated_exercises" back to the server in the submit body?
            // Yes, user could cheat by inspecting payload, but for this app level it's fine.

            const response = await fetch('/submit_test_step', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_id: userId,
                    step_id: stepData.id,
                    answers: userAnswers,
                    // Sending back the exercises so server knows what the questions were
                    generated_exercises: stepData.exercises
                })
            });

            const result = await response.json();

            // Show Feedback
            let correctCount = 0;
            for (const [exId, res] of Object.entries(result.results)) {
                const isCorrect = res.correct;
                if (isCorrect) correctCount++;

                const fbDiv = document.getElementById(`feedback-${exId}`);
                if (fbDiv) {
                    fbDiv.innerHTML = isCorrect ? "‚úÖ Correct" : `‚ùå Incorrect (R√©ponse: ${res.correct_answer})`;
                    fbDiv.style.color = isCorrect ? "var(--success)" : "var(--error)";

                    // Render Math in feedback
                    renderMathInElement(fbDiv, {
                        delimiters: [
                            { left: '$$', right: '$$', display: true },
                            { left: '$', right: '$', display: false }
                        ],
                        throwOnError: false
                    });
                }
            }

            // Mastery Feedback
            let masteryMsg = "";
            let mastery = result.mastery;
            if (mastery === 3) masteryMsg = "üèÜ MA√éTRISE OR ! (3/3)";
            else if (mastery === 2) masteryMsg = "ü•à Ma√Ætrise Argent (2/3)";
            else if (mastery === 1) masteryMsg = "ü•â Ma√Ætrise Bronze (1/3)";

            let msg = `√âtape termin√©e ! Score: ${correctCount} / ${stepData.exercises.length}`;
            if (masteryMsg) msg += `\n\n${masteryMsg}`;

            alert(msg);

            if (result.xp_gained > 0) {
                confetti({
                    particleCount: 150,
                    spread: 80,
                    origin: { y: 0.6 }
                });
            }

            // Disable inputs?
            document.querySelectorAll('button').forEach(b => {
                if (b.id !== 'next-page-btn') b.disabled = true;
            });

            // If next_url exists, maybe show a big "Continuer" button or redirect after delay
            const nextUrl = "{{ next_url if next_url else '' }}";
            if (nextUrl) {
                const nextBtn = document.createElement('button');
                nextBtn.id = 'next-page-btn';
                nextBtn.className = 'btn-primary animate-pulse';
                nextBtn.style.width = '100%';
                nextBtn.style.marginTop = '2rem';
                nextBtn.textContent = 'Continuer ‚ûî';
                nextBtn.onclick = () => window.location.href = nextUrl;
                document.getElementById('exercises-list').appendChild(nextBtn);
            }

        } catch (error) {
            console.error('Error submitting:', error);
            alert('Erreur lors de la soumission');
        }
    }
</script>
{% endblock %}